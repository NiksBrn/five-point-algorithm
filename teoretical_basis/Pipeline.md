## Задача визуальной одометрии (full.py)
Вход: последовательность изображений
    ↓
Шаг 1: Загружаем кадры i и i+1
    ↓
Шаг 2: Детектируем ключевые точки (FAST detector)
    ↓
Шаг 3: Отслеживаем точки между кадрами (optical flow Pyramidal LK)
    ↓
Результат: ~2000 пар соответствий (pts1_good, pts2_good)
    ↓
Шаг 4: Вычисляем Essential Matrix через Five-Point Algorithm + RANSAC
    ↓
Шаг 5: Декомпозируем E $\rightarrow$ R (вращение), t (смещение)
    ↓
Шаг 6: Обновляем глобальную позицию: pos += R_total @ t, R_total = R @ R_total
    ↓
Шаг 7: Визуализируем траекторию
    ↓
Выход: восстановленная траектория камеры

## RANSAC с Five-Point Algorithm
Итерационный процесс:
    Пока не достигнуто расчетное число итераций:
        ↓
        Шаг 1: Случайный выбор 5 уникальных пар точек
        ↓
        Шаг 2: Five-Point Algorithm на выбранной выборке:
            • Построение линейной системы из уравнений эпиполярной геометрии
            • Решение через SVD $\rightarrow$ получение 4-мерного пространства матриц
            • Применение условий Essential Matrix $\rightarrow$ полином 10-й степени
            • Решение полинома $\rightarrow$ до 10 кандидатов матрицы E
        ↓
        Шаг 3: Для каждого кандидата E:
            • Вычисление расстояния Сампсона для всех точек
            • Подсчет инлаеров (ошибка для пары точек < порога)
            • Вычисление средней ошибки на инлаерах
        ↓
        Шаг 4: Обновление лучшего решения:
            • Если найдено больше инлаеров $\rightarrow$ сохраняем матрицу E
            • Обновляем расчетное число итераций RANSAC
    ↓
Выход: Оптимальная Essential Matrix E с соответствующими инлаерами

## Декомпозиция Essential Matrix
Вход: Найденная матрица E
    ↓
Шаг 1: SVD разложение матрицы E
    ↓
Шаг 2: Коррекция сингулярных значений, если для расчетов модели не использовался алгоритм 5 точек ($\sigma _1 =\sigma _2, \sigma _3 = 0 $)
    ↓
Шаг 3: Получение 4 возможных комбинаций (R, t):
    • Два возможных вращения $R_1$, $R_2$
    • Два направления смещения t, -t
    ↓
Шаг 4: Выбор правильной комбинации через триангуляцию:
    • Для каждой пары (R, t) выполняем DLT триангуляцию точек (берем инлаеры)
    • Подсчитываем точки с положительной глубиной перед камерами
    • Выбираем пару, у которой больше всего точек имеет положительную глубину
    ↓
Выход: Матрица вращения R и вектор смещения t между кадрами

## SVD вычисление (svd_qr.py)
Задача: Вычислить SVD матрицы A (A·vec(E)=0)
    ↓
Преобразование: $A^T·A = V·(\Sigma^T·\Sigma)·V^T$
    ↓
Стратегия: Выбрать меньшую матрицу:
    - Если m ≥ n: работаем с B = $A^T·A$ (n*n)
    - Если m < n: работаем с B = $A·A^T$ (m*m)
    ↓
Метод: QR-алгоритм для симметричной матрицы B
    ↓
Итеративный процесс: $B_{k+1} = R_k·Q_k, V_{k+1} = V_k·Q_k$
    ↓
Результат: B $\rightarrow$ Λ (диагональная), V $\rightarrow$ собственные векторы
    ↓
Сингулярные значения: $\sigma_i = \sqrt{\lambda _i}$
    ↓
Восстановление второй матрицы: $U = A·V·\Sigma^{-1} или V = A^T·U·\Sigma^{-1}$
    ↓
Сортировка: По убыванию $\sigma_i$, переупорядочивание U, $\Sigma$, V

## QR-алгоритм (внутри svd_qr.py)
Вход: Симметричная матрица B
    ↓
Инициализация: V = I, B_current = B
    ↓
Итерация (до сходимости или max_iterations):
    ↓
Подшаг 1: QR-разложение B_current = Q·R
    ↓
Подшаг 2: Обновление B_current = R·Q
    ↓
Подшаг 3: Накопление V = V * Q
    ↓
Критерий остановки: норма недиагональных элементов < tolerance
    ↓
Выход: B_current ≈ Λ, V ≈ собственные векторы

## QR-разложение (через Грама-Шмидта)
Вход: Матрица A
    ↓
Процесс для каждого столбца j:
    ↓
Подшаг 1: Взять столбец $a_j$
    ↓
Подшаг 2: Ортогонализовать относительно предыдущих:
        $v_j = a_j - ∑_{k=1}^{j-1} r_{kj}·q_k$
        $где r_{kj} = ⟨a_j, q_k⟩$
    ↓
Подшаг 3: Нормализовать:
        $r_{jj} = ||v_j||$
        $q_j = v_j / r_{jj} (если r_{jj} > ε)$
    ↓
Результат: A = Q  * R, где:
    - Q: ортонормированные столбцы
    - R: верхняя треугольная $(r_{kj} и r_{jj})$